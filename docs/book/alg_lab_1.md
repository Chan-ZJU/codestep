# 时间复杂度

平常写题时会经常看到题目中给出了一个时间范围和空间范围，但是如何来估计自己的算法所消耗的时间？

首先明白时间复杂度的概念，时间复杂度是用来衡量一个算法随着问题数据规模的扩大而时间变化的函数。$t = f(n)$ 我们想要确定的是算法消耗消耗时间的上界，也就是最大值。

那么根据问题所给数据规模和时间复杂度就可以计算出改算法运行时所消耗的时间。

但实际使用中常常都是估算，而且算法常常是以运行次数来估计的，例如一个 for 循环，循环 $10^8$ 次，也就是一亿次所消耗的时间大约为 $0.164s$。 当运行 $10^9$ 次时消耗的时间为 $1.64s$ 。

所以一旦题目中给了限定条件，例如时间不超过 1s (1000 ms) 那么就说明这个算法运行的次数超过 $10^8$ 就有超时的风险。

如果这个算法所给的数据为 1000，而时间复杂度为 $O(N^2)$ ，那么对于 for 循环而言，循环 $1000\times10000=10^8$ 次是不会超时的。 

例如 HDU 的 [1425](http://acm.hdu.edu.cn/showproblem.php?pid=1425) ，题目中所给的时间复杂度为 1000 MS 也就是 1s ，而题中所给的 n 为 1000000 。 

显然如果采用时间复杂度为 $N^2$的冒泡排序，粗略的来算，运行次数也是大于 $10^6\times\10^6 = 10^12$ 次的。所以肯定大于 1s 。必定超时。

如果采用时间复杂度为 $nlog2^{n^2}$ 的快速排序来来计算时间复杂度，最终消耗的时间为 600MS ，可以通过。

# STL

STL 里面包含了很多的数据结构模板，定位是工具，就像铲子一样，练习顺手即可。


# 知识记录

1. fabs(-1.02) = 1.02 , abs(-1.02) = 1 , abs 返回先取绝对值后再取整，fabs 返回取绝对值
2. int gcd(int x, int y) { return gcd(y,x%y);}
3.  取整函数：
 ceil(1.499) = 2;有余数，整数加一，不小于这个数的整数。double型
 floor(1.499)=1;有余数就抹掉，不大于这个数的整数。
 round(1.499)=1;四舍五入

# 参考

[1]《算法竞赛入门到进阶》




