# 时间复杂度

平常写题时会经常看到题目中给出了一个时间范围和空间范围，但是如何来估计自己的算法所消耗的时间？

首先明白时间复杂度的概念，时间复杂度是用来衡量一个算法随着问题数据规模的扩大而时间变化的函数。$t = f(n)$ 我们想要确定的是算法消耗消耗时间的上界，也就是最大值。

那么根据问题所给数据规模和时间复杂度就可以计算出改算法运行时所消耗的时间。

但实际使用中常常都是估算，而且算法常常是以运行次数来估计的，例如一个 for 循环，循环 $10^8$ 次，也就是一亿次所消耗的时间大约为 $0.164s$。 当运行 $10^9$ 次时消耗的时间为 $1.64s$ 。

所以一旦题目中给了限定条件，例如时间不超过 1s (1000 ms) 那么就说明这个算法运行的次数超过 $10^8$ 就有超时的风险。

如果这个算法所给的数据为 1000，而时间复杂度为 $O(N^2)$ ，那么对于 for 循环而言，循环 $1000\times10000=10^8$ 次是不会超时的。 

例如 HDU 的 [1425](http://acm.hdu.edu.cn/showproblem.php?pid=1425) ，题目中所给的时间复杂度为 1000 MS 也就是 1s ，而题中所给的 n 为 1000000 。 

显然如果采用时间复杂度为 $N^2$的冒泡排序，粗略的来算，运行次数也是大于 $10^6\times\10^6 = 10^12$ 次的。所以肯定大于 1s 。必定超时。

如果采用时间复杂度为 $nlog2^{n^2}$ 的快速排序来来计算时间复杂度，最终消耗的时间为 600MS ，可以通过。

# STL

STL 里面包含了很多的数据结构模板，定位是工具，就像铲子一样，练习顺手即可。



# 知识记录

1. fabs(-1.02) = 1.02 , abs(-1.02) = 1 , abs 返回先取绝对值后再取整，fabs 返回取绝对值
2. int gcd(int x, int y) { return gcd(y,x%y);}
3.  取整函数：
 ceil(1.499) = 2;有余数，整数加一，不小于这个数的整数。double型
 floor(1.499)=1;有余数就抹掉，不大于这个数的整数。
 round(1.499)=1;四舍五入
## 代码规范

下面的代表规范大部分是针对 C/C++ 提出的，仅供参考。

* c/c++ 使用万能的头文件 `#include <bits/stdc++.h>` 这个头文件基本上支持了可以替代所有的头文件。注意可能在有的 OJ 上会报错，例如 POJ，但是大部分的 OJ 都能通过。
* 不要使用 C 风格的头文件，例如 `#include <stdio.h>`
* 输入判断结尾不要使用 `while(scanf("%d",&a) != EOF )` ，而用 `while(~scanf("%d",&a))` 。 EOF 代表 -1 ，也就是表明文件结束，而 `~` 则表示取反，而 `~-1 = 0` 也就是一旦扫描到 EOF ，则表示 `~scanf() = 0` 也就是循环结束。如果想设置具体
* 换行采用 K&C 风格，也就是左大括号不换行，右大括号单列一行。
* 变量有限在变量被调用的地方定义，例如：

```cpp
for (int i = 0; i < 10; i++) {
    int k = 10;
}
```
* 最好不要用宏，宏定义和宏函数容易出问题。应该采用 `const int MAX = 100005;` 而宏函数应当写成普通函数。
* 不要用 `#define` 定义常量，而用 `const int MAX = 1000005` 定义常量。 
* 常量名应该全部大写。
* 数组如果比较大，需要放在 main() 函数外部，作为全局变量，因为在 main() 内部使用的是栈空间，占用空间太大会导致栈溢出！
* 如果题目已经给出数据范围，那么直接用数组会比较快，不要用包装的容器。例如： stack,queue.
* 判断数据大小不要用  `a == b` ，应使用 `fabs(a - b) < 1e-9`，1e-9 视情况而定，因为二进制对小数的处理存在缺陷。
* 判断整数是否为奇数时 用 `x%2 != 0` 因为 `x%2 == 1` x 可能是负数，负数无奇偶之分。
* char 的范围可能为负，统计频次时注意负数，

# 参考

[1]. [acm-cheat-sheet](https://github.com/soulmachine/acm-cheat-sheet)

[2]. [《算法竞赛入门到进阶》](https://book.douban.com/subject/34465629/)





