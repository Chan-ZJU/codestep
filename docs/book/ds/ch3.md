# 第三章：栈和队列

# 1. 概述

栈是特殊的线性表，也就是只能在一端进行插入或删除。

空栈：栈中没有元素。栈顶指允许删除和插入的一端，栈底则反之。

栈是先进后出，Last In First Out 简称 LIFO

队列是先进先出，First In First Out 简称 FIFO 

题型：判断出栈顺序，出栈顺序的所有可能为卡特兰数。

栈可以的存储结构可以采用静态实现也就是数组或指针，也可以采用动态实现的方式也就是链栈。

根据栈的存储结构实现方式可以将其分为顺序栈（数组/指针），共享栈和链栈（是否带头节点）三种实现方式。

# 2. 顺序栈

* 根据栈的特性思考栈的数据结构，采用两个指针，一个指向头部，一个指向栈底。

```cpp
typedef struct SqStack {
    ElemType *top; 
    ElemType *base;
}SqStack;
```

* 也可以采用静态存储，用数组直接存。

```cpp
typedef struct SqStack {
    ElemType data[Maxsize];
    int top;
}SqStack;
```

静态栈的栈满后想要扩展是比较麻烦的。

## 2.1 栈的基本操作

如果采用指针来实现，初始头部和尾部在同一个位置。`S.top = S.base;`

如果采用数组来实现，那么 top 值需要明确一下定义。

根据 top 的定义来设定其值，一般而言 top 指针存在两种定义方式。

* 一种是指向当前栈顶元素，那么 top 初始值就是 -1，因为 0 位置最初没有存元素。所以判断栈是否为空时可以直接判断 top 是否等于 -1 即可。

* 另一种是指向栈顶元素后面一个位置的元素，top 初始值为 0 。判断栈空的条件是 `top == 0`

入栈：要先判断栈是否满了，没有满再进栈，头部指针加一，尾指针不动，

出栈：出栈就反过来了，需要先判断是否到达栈底了，如果没有就出去，反之不行。

# 3. 共享栈

共享栈指两个栈共享同一块内存空间，二者相向生长。对于两个栈而言自己的栈底是对方的栈顶而对方的栈顶则是自己的栈底。实际上就是为了更好的利用存储空间。

`top0 == -1` 表示 0 号栈栈空，`top1 == MaxSize` 表示 1 号栈栈空。

`top1 - top0 == 1` 表示栈满。 
# 5. 链栈

链栈没有采用数组存储而是采用的链表的方式存储，和单链表类似。所以顺序栈的空间是连续的而链栈的空间是离散的。

# 4. 队列

队列表示只能在一端进行插入，另一端进行删除。先进先出（FIFO）。

术语：队头元素指执行删除元素的一端，队尾元素指指向插入元素的一端，空队列指队列中元素为空的情况。

采用静态数组来存储，结构体要分别定义队头和队尾两个指针。

循环队列，因为删除操作导致空间出现剩余，所以队尾指针经过取余操作跳转到这块内存可空间的头部。 

## 4.1 空队列和满队列的判断

队列已满的条件判断，存在以下三种方法。因为队满和队空的情况仅靠头指针和尾指针是无法区分的。第一种方法是浪费一块存储空间，后两种方法则是增加辅助变量。

1. 循环队列要空出一个元素用于判断队列是否为空，因为头指针和尾指针指向同一个位置表示队列为空，而队尾经过不断的插入循环回来最终也会指向队头指针，所以要空出一个元素。

2. 也可以在结构体中增加一个属性 size 用于判断队列长度，所以就不用浪费一个节点了。

3. 可以增加一个变量，用于判断执行的是插入操作还是删除操作。对于队满的情况，一定是插入操作所导致的，对于队列为空的情况一定是删除操作所导致的。这样就可以区分队满和对空的情况了。

## 4.2 队列元素个数计算

队列元素个数计算：`(rear + Maxsize - front)%Maxsize` 。

## 4.3 队尾指针定义

注意区分队尾指针的定义，定义不同代码实现也不同，一般存在以下两种定义方式：

1. 指向当前队尾元素。
2. 指向队尾元素的下一个元素。

# 5. 表达式求值

## 5.1 表达式的组成

表达式由操作数，运算符和界限符三部分组成。

> 例如：$((1+2)*3)$ ，其中 1 2 3 是操作数，+ * 是操作数，( ) 是界限符。界限符保证了运算的次序。否则删除界限符运算次序就改变了 $1 + 2 * 3$ 。

## 5.2 后缀表达式，前缀表达式

后缀表达式由操作数和运算符两部分组成，删除了界限符，也就是左右括号。

但是为了保证运算次序，肯定不能单纯的删除界限符，需要存在一定的逻辑。

## 5.3 中缀转后缀，中缀转前缀。

运算符在两个操作数后面，变换逻辑如下：

> 例如： a + b      =>  a b +
>       a + b - c  =>  a b + c -
>       a + b - c  =>  a b c - +    （中缀表达式转后缀表达式不唯一！）

中缀表达式：运算符在两个操作数前面。

> 例如： a + b - c       => - + a b c
>       a + b - c * d   => - + a b * c d

后缀表达式也叫逆波兰式，同理前缀表达式称为波兰式。

因为不同的计算次序出来的结果不同，为了方便排错建议按照左优先来计算，和算法流程保持一致。

同理，中缀转前缀按照右优先的原则，也就是只要右边的运算符能先计算就优先算右边的。

## 5.4 中缀表达式求值

有两种方式，一种是采用一个栈来模拟，先将中缀表达式转换成后缀表达式。

然后后缀表达式逐渐压入栈中，遇到操作数就弹出计算，将结果压入其中，不断重复该过程。

除此之外可以采用两个栈来模拟，分别是运算符栈和操作数栈。

> 难点：中缀表达式转后缀表达式算法。

> 更新于：2021/02/07 2:47

