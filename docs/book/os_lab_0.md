# 概述

## 概念

用户 => 软件 => 操作系统 => 硬件

操作系统：
* 负责管理协调硬件，软件等计算机资源的工作。
* 为上层的应用程序，用户提供简单易用的服务。
* 操作系统是系统软件，而不是硬件。（最接近硬件的软件。）

## 操作系统的功能和目标
1. 系统资源的管理者，需要提供什么功能？
   1. 文件管理功能 （找到存在磁盘中的文件）
   2. 存储管理 （将磁盘中的文件加载到内存中）
   3. 处理机管理 （将内存中的文件加载到 CPU 中）
   4. 设备管理 （外设，鼠标，键盘，摄像头的交互管理）
2. 作为用户与计算机硬件之间的接口，为其上层的用户，应用程序提供简单易用的服务所实现的功能？
   1. 命令接口 （允许用户直接使用）
      1. 联机命令接口 （交互式）
         1. 用户说一句，系统做一句。
      2. 脱机命令接口 （批处理）
         1. 用户说一堆，系统做一堆。
   2. 程序接口 （系统调用 = 系统调用命令 = 广义指令）（dll 动态链接库实现）
   3. GUI 图形界面
3. 作为最接近硬件的软件，在纯硬件的基础上需要实现什么功能？

<img src="https://gitee.com/weijiew/pic/raw/master/img/20200517180726.png"/>


# 操作系统的特征

* 并发：并发是指微观上多个事件交替执行，从而实现宏观上的同时执行，而并行则是在微观上的同时执行多个事件。单核 CPU 是并发操作，而多核 CPU 可以实现并行操作。
* 共享：同一时间段内只允许一个进程访问该资源称为互斥，例如摄像头权限，而同时访问多进程访问则是共享，例如不同软件发送文件。
* 虚拟：虚拟分为空分复用技术和时分复用技术，前者是虚拟存储器技术而后者是虚拟处理器。（依赖并发实现）
* 异步：多个程序并发执行，速度不可预知。（依赖并发）

# 发展和分类
1. 手工操作阶段：打孔机
   1. 缺点：用户独占全机，人工输入慢，机器处理快。
2. 批处理阶段
   1. 单道批处理系统：虽然缓解了人机速度的矛盾，但是只能处理一个任务，大量时间用于 I/O
   2. 多道批处理系统：多道程序并发执行，资源利用率高，但是不具备人机交互功能，只能等所有程序都执行结束后查看结果。
3. 分时系统：提供人机交互，以时间片的形式分配给程序运行。但是不能优先处理紧急人物，每一个人物都是平等的。
4. 实时系统：分为硬实时操作系统和软实时操作系统，前者严格规定时间，后者可以有缓和的余地。优点是提供了优先级，重要的命令先处理。
5. 网络操作系统：资源共享，计算机通信。
6. 分布式操作系统：分布，并行。
7. 个人计算机操作系统：win，mac，linux

# 操作系统的运行机制和体系结构

## 运行机制

指导 CPU 运行的是指令，指令是 CPU 可以直接处理的，也就是机器码，而人类写出来的代码并不能直接被 CPU 所识别，需要使用编译器将其编译为机器码。

指令分为两种类型，特权指令和非特权指令，其中特权指令可以使 CPU 做一些危险敏感的操作，例如删除，格式化等。非特权指令则反之，都是一些常见操作。

根据指令的两种类型，CPU 在处理指令之时分为核心态和用户态两种状态，特权指令在两种状态中都可以运行，但是非特权指令只能在用户态中运行。而两种状态的转换在寄存器中，寄存器是 CPU 中的一个小单元，在寄存器中采用某个标志位来标识，例如 0 表示用户态，1 表示核心态，这样实现了用户态和核心态的转换。

由此，程序在使用 CPU 之时，根据 CPU 的处理状态，可以将程序区分内核程序和应用程序。内核程序比较重要，涉及到计算资源的处理，没有操作系统就无法运转，反之应用程序对于操作系统的运行可有可无。就像人体一样，没有脑子没有心脏就死了，但是没有腿，没有手还能够生存。脑子，心脏就相当于内核程序，而像手，脚相当于应用程序。

## 体系结构

操作系统内核涉及到的功能有时钟管理，中断处理，原语，对系统资源进行管理的功能，如进程管理，存储器管理，设备管理。

操作系统的体系结构分为大内核和微内核两种类型，大内核的优点是高性能，缺点则是内核代码庞大，结构混乱，难以维护。而微内核则是代码功能少，结构清晰，方便维护。缺点则是需要频繁的在用户态和内核态之间进行切换，性能低。

# 系统调用

## 系统调用

系统调用是操作系统给应用程序提供的接口，应用程序通过系统调用来获得操作系统的服务。

系统调用会使得处理器从用户态进入核心态。

系统调用分为：设备管理，文件管理，进程控制，进程通信，内存管理，凡是与资源相关的操作，会直接影响到其他进程的操作一定需要操作系统的介入，也就是需要通过系统调用来完成。

涉及到系统调用的操作一般都与资源有关，或者直接影响到其他进程的操作，必须通过系统调用来实现。

## 系统调用和库函数的区别
系统调用是操作系统向上层提供的接口，但是为了简化使用，中间加了一层库函数，库函数对这些接口进行了进一步的封装。如今编写的程序大都是通过高级语言提供的库函数简介的进行系统调用。

对于库函数而言，涉及到使用系统调用才会去使用，而一些简单的请求就不会去使用系统调用，例如取绝对值操作，而像创建一个文件这种操作则需要系统调用。 

## 系统调用背后的过程
当写好代码后，代码中存在一个向其他文件写入字符的操作之时， CPU 将编译好的代码执行，执行到写入操作之时，将要存入的数据写入某个通用寄存器中。然后执行陷入指令（访管指令），陷入指令使得 CPU 的控制权变成了操作系统，由操作系统来将存在寄存器中的这个数据写入文件中，操作系统调用相应的服务程序，完成后再返回用户程序。

陷入指令是在用户态下执行的，而对系统调用的相应处理在核心态下进行。发出系统调用是在用户态，而对系统调用的处理是在核心态下进行。通常而言核心态下既能处理特权指令也能处理非特权指令，但是陷入指令是唯一一个不能在核心态下执行的指令，只能在用户态下执行。

执行陷入指令会产生内中断，内中断使得处理器从用户态进入到核心态。

# 进程

## 定义

程序就是一个指令的序列，最开始的 CPU 只能一个程序一个程序的处理，也就是只支持单道程序。并且此时的 CPU，内存，I/O设备都被这个程序所独占。这样做显然效率很低。此时内存中分为程序段和数据段，程序段用于启动程序，数据段用于存放程序运行过程中所需要的数据。

后来引入了多道程序技术，使得 CPU 可以处理多个程序，但是程序间的切换，谁先谁后这些功能需要操作系统来完成，而控制这些程序的数据需要存在一个地方且需要管理，所以为了方便操作系统的管理引入了进程，进程实体的概念。

在内存段中系统为每一个进程分配了一个数据结构，称为进程控制块（PCB），PCB 记录了进程的所有信息。所以一个完整的进程分PCB，程序段，数据段三部分。也成为进程实体或进程映像。

一般情况下，进程实体简称为进程。创建进程就是创建 PCB，撤销进程就是撤销进程实体中的 PCB，PCB 唯一标识了进程的存在。

从不同的角度来看，进程可以有不同的定义。例如进程是程序执行一次的执行过程，进程是一个程序及其数据在处理机上顺序执行时所发送的活动。进程是具有独立功能的程序在数据集合上运行的过程（动态性），是系统进行资源分配和调度的独立段位。

严格而言进程和进程实体不同，进程实体是程序段，数据段，PCB三者的集合，是静态的。而进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位，强调动态性。除非单独考察二者的区别，通常情况下是不做区分。

## 组成
进程（进程实体）由程序段，数据段，PCB三部分组成。
* 程序段：存放程序代码。
* 数据段：存放程序执行时涉及到的数据。
* PCB：存放进程信息。进程描述信息，进程的控制和管理信息，资源分配清单，处理机相关信息。
  * 进程描述信息有进程标识符 PID 用户标识符 UID 当进程被创建后，操作系统会为进程分配一个 PID，用于区分不同进程。
  * 进程控制和管理信息：存放进程的当前状态和进程的优先级。
  * 资源分配清单：程序端指针，数据段指针，键盘，鼠标等。
  * 处理机相关信息：各种寄存器的值，也就是进程执行过程中产生的中间值，假如此时 CPU 需要处理别的进程，当前进程需要暂时停止，那么需要将当前的记录保存下来存放到这里，下次启动的时候从这里在拿出来放到寄存器中。相当于“快照”。

## 组织方式
进程与进程间如何组织。分为链接方式和索引方式。

根据进程状态将 PCB 分为多个队列，操作系统持有各个队列的指针。

根据进程状态建立几张索引表，操作系统持有指向各个索引表的指针。 

指向进程的有三种指针，分别是执行指针，就绪指针，阻塞指针。

执行指针指向当前正在执行的进程。

就绪指针指向等待执行的进程。

阻塞指针指向阻塞住的进程。

而根据进程间的组织方式，链接方式中，三种指针称为执行指针和就绪队列指针阻塞队列指针。而索引方式下的三种指针称为执行指针，就绪表指针，阻塞表指针。

## 特征特征
进程和程序截然不同，差别如下：
* 动态性：进程是程序一次执行的过程，动态的产生，变化和消亡。
* 并发性：内存中有多个进程实体，各个进程可以并发执行。
* 独立性：进程是资源分配，接受调度的独立单元。
* 异步性：各个进程间执行速度不同导致进度不同，需要采用进程同步机制来解决异步问题。
* 结构性：每一个进程都会配置一个 PCB。


# 进程的状态和状态间的转换

进程就是程序运行的过程，一个核可以同一时间内可以处理一个进程，所以同一时间内 n 个核就可以处理 n 个进程。

在运行时根据 CPU 的处理可以将进程分为三种状态，运行态，就绪态，阻塞态。

运行态指 CPU 正在处理当前进程。

就绪态指进程正在等待被 CPU 所处理。

阻塞态指进程被 CPU 处理时，CPU 切换到了别的进程之上。此时这个进程就处于阻塞态。例如 a 进程是执行打印操作，将磁盘数据读入内存中时 CPU 是闲置的，为了提高 CPU 的利用率，将 CPU 切换到了别的进程 b 之上进行处理。此时 a 进程是阻塞的，当数据读入内存完毕后再切换回来继续执行 a 进程的后续指令。 

除此之外，还有两种状态，创建态和终止态。

起初，进程是由操作系统进程创建的，操作系统为进程分配资源，初始化 PCB 。

最后，当进程执行完毕后，需要从系统中撤销，操作系统会回收该进程所拥有的资源，撤销 PCB。

总结：进程存在五种状态分别是创建态，执行太，就绪态，阻塞态，终止态。

## 进程状态的转换


运行态 ： CPU✅ 其他资源✅

就绪态 ： CPU❎ 其他资源✅

阻塞态 ： CPU❎ 其他资源❎

创建态 ：OS 为进程分配资源，创建 PCB

终止态 ：OS 回收进程资源，撤销 PCB



创建态 => 就绪态 ： 系统完成一系列工作，初始化 PCB 。

就绪态 => 运行态 ： 此时进程被调度。

运行态 => 就绪态 ： 时间片耗尽或者处理机被占用也就是被其他高优先级的进程抢占。

运行态 => 阻塞态 ： 进程**主动**用系统调用的方式申请资源。此时不具备处理机和其他资源。阻塞态不能反过来直接转为运行态。

运行态 => 终止态 ： 进程运行结束或者遇到了 BUG ，变成了终止态。

阻塞态 => 就绪态 ：申请的资源被动的分配或等待事件发生。就绪态也不能直接转为阻塞态，因为阻塞态是进程运行时主动申请的，就绪态的进程没有运行，所以需要在运行态才能进行转换。


# 进程控制

## 基本概念
进程控制就是对进程的管理，例如创建新进程，撤销已有进程，实现进程状态转换等功能。

## 原语
原语是用来实现进程控制的，有些操作必须一次性执行完不允许中断。也就是原子操作。

原语采用 “关中断指令” 和 “开中断指令” 实现。这两个指令权限非常大，是在核心态下执行的特权指令。指令间的代码必须一次性执行完毕，不可以中断，这样实现了原语的特性。

进程控制中，原语使用有三个特性：

1. 更新 PCB 厚葬的信息。
2. 将 PCB 插入合适的队列中
3. 分配/回收 资源

进程创建 ：

* 创建原语：首先申请空白的 PCB ，为其分配资源，初始化 PCB，将 PCB 插入阻塞队列中。

引起进程创建的时间有：用户登录，在分时系统中用户登陆成功后会为其分配一个进程。作业系统，分道批处理系统中，当新的作业出现在内存中时会建立一个新的进程。提供服务，用户向OS提供某些请求时会创建新的进程来处理这些请求。应用请求：用户进程主动创建子进程。

* 进程的终止：如就绪态转换为阻塞态， 撤销原语步骤，首先从 PCB 集合中找到终止进程的 PCB ，如果进程正在运行，立即剥夺 CPU ， 将 CPU 分配给其他进程。终止所有子进程，将该进程所拥有的资源返回给父进程或 OS ，最后删除 PCB 。

引起进程终止的事件： 正常结束，异常终止，外界干预。

* 进程的切换：原语流程为首先将运行环境信息存入 PCB ，将 PCB 移入相应的队列中，选择另一个进程执行并更新 PCB ， 根据 PCB 恢复新的进程所需要的运行环境。

引起进程切换的事件：当前进程时间片到，更高优先级的进程出现，当前进程主动阻塞，当前进程终止。


# 进程通信

进程之间就是相互进程间交换信息，例如手机中的照片，qq 可以访问，微信也可以访问，属于共享的资料。

进程拥有独立的内存地址空间。为了保证安全，进程之间不能直接访问，但是进程之间需要交换信息，所以出现了三种通信方式，分别是：共享存储，消息传递，管道通信。

## 共享存储

在内存中有一块空间用于进程和进程间的通信，这块空间对于两个进程来说是互斥的，不能同时操作。

根据存储方式分为两种类，基于数据结构的共享，由操作系统控制，例如这块空间中存放一个数组，通过数组来交互信息，但是这种方式速度慢，限制多，是低级的通信方式。

另一种是基于存储区的共享，由进程本身来控制，在内存中划出来一块内存，存放数据的形式和存放的位置。这种方式速度快，更高级的通信方式。

## 管道通信
管道是内存中的一块缓冲区，管道采用半双工通信，也就是某一时间内只允许单向传输，如果想要实现双向需要设置两个管道，并且管道的访问是互斥的。

当管道满了后，写进程会被阻塞，只有留出空位后才后续的才会被写入。同样，当管道空了后，读进程会被阻塞，只有管道里面有数据时才会被读取。

数据一旦被读出数据就会被管道所抛弃，所以只允许有一个读进程，否在数据存在读错的情况。

## 消息传递

消息是由消息头和消息体组成，消息头里面由消息的发送过程ID，接受过程ID，消息类型，消息长度，等格式化信息。

消息传递分为两种类型：直接通信方式，间接通信方式。

直接通信方式会将消息挂在消息缓冲队列上，等待接受方进程来处理。

间接通信则是通过发送原语将消息发送给第三方，也就是邮箱，接受进程再通过接受原语将信息。

# 线程
为了进一步的实现并发，引入了线程的概念，线程相当于轻量级的进程，在进程内部有多个线程的存在。之前的进程只能串行，引入线程后增加了并发度。

线程是程序执行流的最小单位。线程是 CPU 执行的最小单元，也是程序执行流的最小单元。引入线程后不仅进程间可以并发，进程内也实现了并发。

线程引入后，进程只作为除 CPU 之外的系统资源的分配单元。

## 线程带来的变化

资源分配调度方面：引入线程之前，进程是资源分配和调度的最小单位，引入之后，调度的最小单位就变成的线程，进程只承担资源分配的最小单位。

并发性：线程之前，进程之间才可以并发，引入线程后，进程内部通过线程就可以实现并发。提升了并发度。

系统开销：引入线程前，进程间的并发需要切换运行环境，系统开销非常大。引入线程后，如果在同一个进程下进程线程切换就不要切换环境了，系统开销小。

## 线程的属性

* 线程是处理机调度的单位。
* 多个 CPU 计算机中，各个线程可以占用不同 CPU 。
* 每个线程都有一个线程ID，线程控制块 PCB 。
* 线程也有就绪，阻塞，运行三种状态。 
* 线程几乎不拥有系统资源。
* 同一个进程内的线程之间共享线程资源。
* 由于进程内的内存空间地址是共享的，所以同一进程内的线程通信不需要干预。
* 同一进程内的线程切换不会引起进程的切换。
* 不同进程中的线程切换回引起进程切换。
* 同一个进程内的线程切换系统开销很小。
* 切换进程，系统开销非常大。

## 线程的实现方式
线程同样分两种类型，用户级线程，内核级线程。前者处于用户空间，后者则处于内核空间。

用户级线程：从用户级别才能看到的线程，操作系统是不干预的，看不到线程的存在。线程的管理切换都由应用程序通过线程库来管理。

内核级线程：内核级线程是在核心态下运转的，由操作系统控制。因为操作系统看的见，所以内核级线程才是处理机分配的单位。

有些 OS 支持内核级线程，有的则支持用户级线程，而有的则同时支持二者。

当同时支持二者的 OS 使得内核级线程和用户级线程的交叉组合，出现了“多线程模型”

多对一：多个用户级线程对应一个内核级线程。优点是切换线程时不涉及内核，切换方便开销小，缺点是如果一个线程卡住，那么整个进程就卡住了。并发度不高并且多个线程不可在多核处理机上并行运行。

一对一：一个用户级线程对应一个内核级线程，优点是并发度高，多线程可在多核处理机上并行执行。当一个线程阻塞后，别的线程还能继续执行。缺点是切换线程时涉及到内核线程改变，开销大。线程管理的成本高。

多对多：多个用户级线程 n 对应多个内核级线程 m （n > m） 克服了并发度不高的问题同时也具备切换线程开小的优点，便于管理。


# 处理机调度

## 基本概念
调度就是合理安排人物的顺序，效率最大化。在多道处理系统中，所有的人物不可能同时处理，所以一定需要一个顺序，这个顺序用算法怎么来描述。

## 三个层次
高级调度：因为内存空间有限，所以需要将多余的作业放到磁盘中，在内存中建立其对应的 PCB ，之后再来安排分配内存资源。高级调度是指任务在内存和外存之间的调入调出问题，每个作业只调入一次，调出一次。高级调度控制的是调入问题，调入后建立相应的 PCB 。调出则是任务结束被调出删除 PCB 。

为了提高内存利用率和系统吞吐量，引入了虚拟存储技术，将暂时不能运行的任务调至外存等待，直到重新具备运行条件后且内存有了剩余空间才重新调入内存中。

暂时调到外存等待进程状态为挂起状态，当被调入外存后，PCB依旧停留在内存中，并且回记录存放在外存中的位置，以便于下次再次调入。操作系统通过 PCB 来对进程数据控制管理，处于挂起状态进程的 PCB 会被存放在挂起队列中。

中级调度就是给处于挂起状态的进程排序，什么时候调用什么时候挂起。可以多次调用挂取，比高级调度使用更为频繁。

## 三个调度的联系，对比
高级调度也称为作业调度，从后备队列中选择合适的作业将其从外存调入内存中，并且为其创建进程。发生频率低。

中级调度也称为内存调度，从挂起队列中选择合适的进程将数据调回内存中。发生频率高。

低级调度也称为进程调度，按照某种规则从就绪队列中选择合适的进程为其分配处理机。发生频率最高。

## 补充知识

调入外存的状态称为挂起状态，挂起态又可以进一步细分为就绪挂起，阻塞挂起。

所以五种状态再新添加两种状态。


# 进程调度的时机切换与过程调度方式

进程调度就按照某种算法从就绪队列中选择一个进程为其分配处理机。

需要进程进程调度与切换的情况：

1. 当前允许的进程主动放弃处理机。
   1. 进程正常终止
   2. 允许过程发生异常而终止
   3. 进程主动请求阻塞（例如等待I/O）
2. 当前允许的进程被动放弃处理机。
   1. 分配给当前进程的时间片用完了。
   2. 更紧急的事需要处理（例如I/O中断）。
   3. 有更高优先级的进程进入就绪队列。

不能进行进程切换的情况：

1. 中断处理过于复杂做不到进程切换。
2. 进程在操作系统内核程序临界区中。
3. 涉及到原子操作时（原语）。

# 调度算法的评价指标

## CPU 利用率

利用率 = 忙碌的时间 / 总时间 。

## 系统吞吐量

系统吞吐量 = 总共完成了多少道作业 / 总共花了多少时间。 单位时间内完成作业的数量。

## 周转时间

从提交到完成。

平均周转时间 = 各作业周转时间之和 / 作业数量。

带权周转时间 = 作业周转时间 / 作业实际运行的时间。

## 等待时间

进程/作业 初一等待处理状态时间之和。等待时间越长，用户满意度越低。

## 响应时间

# 调度算法

## 先来先服务（FCFS）

## 短作业优先（SJF）

## 高响应比优先（HRRN）


https://www.bilibili.com/video/BV1YE411D7nH?p=15