# 网络层

网络侧只负责尽力转发数据包，不保证质量，丢失就重传。

# 网络层的两种服务


根据网络层是否建立可靠的通信来区分，出现了，虚电路服务，数据报服务。

## 虚电路服务

虚电路：虚电路服务保证了网络层承担可靠的服务，即保证信息送达对方，但是这种服务带来的缺点是需要昂贵的硬件支撑，为了保证传输的可靠性需要昂贵的程控交换机。

* 面向连接的通信
* 建立虚电路，也就是逻辑上的电路，并不是真正物理上的连接，保证通信所需的资源。
* 不要填写目的地址，只需要虚电路的编号。
* 加上可靠传输的网络协议可以使实现无差错传输。


原理：虚电路并不是物理上的线路，而是逻辑上的，建立的过程则是虚拟电路建立，数据传送，虚拟电路拆除。

例子：ATM 机，电话线路等电信服务使用的是虚电路服务。

## 数据报服务

* 因特网的设计思路
* 网路层向上只提供数据报的交付服务，尽最大努力的提交。
* 发送分组时不需要建立连接，每个分组独立发送，与其前后分组无关。
* 网路层不提供服务质量承诺，所以传送容易出错。
* 路由器可以设计简单价格低廉。因为不提供端到端的**可靠**服务。
* 关于差错的控制交给运输层来负责。
* 网络的造价降低，运行灵活，适合多种应用。

数据报：数据报服务提供的是不可靠的传输，不保证数据完整送达，送不过去那就重传，直到可以送达为止，实现尽最大努力的交付！对硬件要求不高，可靠性交给传输层来做。

原理：整个过程不需要建立连接，首先数据报服务将信息分组，每一组独立发送，这样可能会导致分组丢失，出错重复失序等问题，出现问题就重新传送，计算机有很强的差错控制。

例子：因特网采用的就是数据报服务，因为低廉的硬件，计算机强大的差错控制。


## 两种服务的区别
* 虚电路服务的网络层保证服务质量，而数据报服务则将其交给运输层来保证。
* 虚电路服务需要建立连接，而数据报服务不需要。
* 进行分组时，虚电路服务按顺序到达，数据包服务不一定按顺序。
* 终点的地址在建立连接时使用，而数据报服务的每个分组都有完整的地址。
* 分组与分组，如果在同一条虚电路上就按同一路进行转发，数据报服务中的分组则是独立的自己选择路由转发。
* 如果某个节点出现故障，那么这个节点上的虚电路都不能工作，而数据报可能会在这个节点上丢失一些分组。
* 差错控制和流量控制虚电路服务中则是由网络负责或用户主机负责，数据报服务则是由用户主机负责，网络层不负责。

其实这些服务本质上都是向下给运输层提供的服务。

服务的目的是为了实现可靠的交付。

但是由网络还是端系统来负责存在争议，就是二者的区别！



# IP 地址

IP 地址可以标识一台主机，一共 32 位，不同地域下不同，所以 IP 地址唯一标识了主机所在的位置。而 MAC 地址虽然也能唯一标识一台主机，但是根据其结构只能拿到生产厂家的信息。

关于 IP 地址的发展划分为三阶段： 分类的IP地址，子网的划分，构成超网。

## ip 组成结构

ip 地址由网络号和主机号组成。
* 网络号：net-id 标志这个主机所连接到的网络，每一个网段对应一个网络 ID。
* 主机号：host-id 标志着该主机或路由。

网络号确定了大致范围，而主机号则确定了范围内的具体位置。 

ip 地址分为五类， A / B / C / D / E

<img src="../imgs/net/net-01.png">

32 位的二进制 IP 地址每八位分割开来，形成了 4 段，每一段在转成十进制就是我们现在经常看到的。而段与段直接用 . 来分割，也就是点分十进制记法。


## IP 地址的特点

* IP 地址的网络号由管理机构分配，剩下的主机号则有单位自行分配。
* 路由器只根据网络号去转发分组降低了路由表中的项目数。减小了存储空间。

# IP 地址和 MAC 地址

IP 称为逻辑地址，硬件地址也就是MAC地址，也就是物理地址。

IP 地址放在数据IP数据报的首部，而 MAC 地址放在 MAC帧的尾部。

IP 地址就像送快递一样，拿到目的第在中间的路由器中不断的转运。

网络层之的地址是 IP 之下是 MAC。从虚拟的 IP 层面来看可以看成 IP 数据报的流动。

IP 层封装了底层复杂的细节，抽象起来再网络侧讨论主机与主机间的通信。

流程如下：

<img src="../imgs/net/net-02.png">

# ARP
通俗的讲 ARP 协议是用来解析ip地址和硬件地址的。其内部有一个高速缓存，这个缓存将ip 地址和物理地址进行了映射。随着时间的变化映射还会失效。

通过以下这个例子可以了解 ARP 体现的作用：

现在有两个计算机（A/B）相互通信，A 向 B 发送一段信息，这段信息从上至下层层包装，A 知晓的是 B 的 IP 地址，但是这段消息想要送达 B 则需要知晓其 MAC 地址。也就是需要将 对方的 MAC 地址封装到消息的头部。

假设第一次发送消息 A 先去看一下自己的 ARP 缓存表中看一看之前有没有连接过 B 的主机，如果连接过并且没有过时，那么就记录过主机 B 的 IP 地址对应的 MAC 地址，将这个 MAC 地址直接封装到头部就可以。

如果发现没有 ARP 缓存表中没有 B 主机的记录。那么主机 A 就会执行 ARP 程序，发送一个 ARP 请求的报文广播包，这个包里面记录了自己的 IP 地址（源IP）和 MAC 地址以及对方的 IP 地址（目的IP）等信息，如下所示：

```bash
source mac：1111.1111.1111.1111.1111
source IP： 1.1.1.1
target mac：ffff.ffff.ffff.ffff （因为第一次通信，不知道对方的mac地址）
target IP：1.1.1.2
```
交换机接受到广播包后，发现目的地 MAC 地址全是 ffff，交换机就知道了主机 A 想找主机 B 的想法，于是交换机就开始广播，。

交换机只是二层设备，只会拆包，不会进行更深的解析，只知道数据包的源，目的 MAC 地址。

当 B 主机发现了广播包后，比对了一下里面的 IP 地址，发现里面目的地 IP 地址是指向自己的，知道了有机器想给他发消息，然后主机 B 会根据广播包中记录的 A 主机的 MAC 地址，将自己的 MAC 地址给主机 A 。单播给主机 A 。

```bash
source mac：2222.2222.2222.2222
source IP： 1.1.1.1
target mac：1111.1111.1111.1111 （从请求包里得知A的mac地址，于是单播）
target IP：1.1.1.1
```
主机 A 拿到 B 回应的报文后，将 MAC 地址封装到信息上，然后将这个报文再存在 ARP 缓存表中，下次就可以直接查表使用。

在 CMD 下通过 `arp -a` 查看主机的 ARP 表，我的如下：

```bash
C:\Users\***>arp -a
接口: 192.168.28.1 --- 0x8
  Internet 地址         物理地址              类型
  192.188.28.255        ff-ff-ff-ff-ff-ff     静态
  224.0.0.251           01-00-5e-00-00-fb     静态
  239.255.255.250       01-00-5e-7f-ff-fa     静态
  ................................
```

# IP 数据报的首部格式

数据报 = 首部 + 数据部

首部 = 固定部分 + 可变部分

固定部分 = 20 字节

首部组成：

<img src = "../imgs/net/net-03.png">

# IP 层转发分组的流程

# 划分子网

# 无分类编址

# RIP 协议
# OSPF 协议

# BGP 协议

# IPv6 协议


# ICMP 协议

* 用来测试网络层是否故障。 命令 ping 的实现，比较常用。

局域网的延迟应该小于 10 ms 。

TTL： 数据包最多经过 64 个路由器，每经过一个就减一。可以用来初略的判断对方的系统，不同的系统初值不同，分别是：linux 64 windows 128 Unix 255 

# IGMP
* 点到点
* 广播
* 多播


# 参考

[1]. [ARP ](https://blog.csdn.net/u010164190/article/details/79446575?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2)