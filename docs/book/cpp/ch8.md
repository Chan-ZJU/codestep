# 第八章：函数探幽

内联函数提高了程序的**运行速度**。虽然和常规函数的编写方式不同，但是**主要区别**在于组合和到程序中的方式。

执行普通函数时需要进行跳转到函数所在位置去执行代码，执行完毕后再跳转回来。

内联函数不一样，将函数直接放在调用函数的位置上直接执行而不跳转，虽然节省了时间但是也增大了内存的消耗。

内联函数对于时间的优化在于调用函数的过程。

如果**执行函数**所占的时间大于**调用函数**的时间，那么使用内联函数节省的时间会比较少。反之如果**执行函数**的时间小于**调用函数**的时间，那么使用内联函数可以节省大量的时间。

除此之外如果该函数经常被调用也会节省大量的时间，反之则节省的时间较少。

内联函数不能递归。

内联函数和普通函数的区别在于前面加了 inline 关键字。

```cpp
inline double square(double x) {return x * x;}
```

在 C++ 中 & 运算符除了做取地址的功能外还可以作为变量的引用。

> 例如： `int a = 101 , int & b = a;` 此时 b 是 a 的一个引用，也可以认为是别名，二者的地址相同。

和指针不同的是在声明时就要初始化。

> 例如： `int a , int & b, b = a` 会报错。

和一个变量关联后就不能修改！

> 等价于：  `int & a = b; int * const a = &b;` 具有和 const 类似的功能。

**值传递**和**引用传递**的区别在于，前者是产生了一个副本，而后者则是实实在在的在本体上进行的修改。

可以采用引用函数参数来实现引用传递。

```cpp
void grumpy(int &x)
```

三种传递方式：

```cpp
void swapr(int &a, int &b); // 引用传递
void swapr(int *a, int *b); // 地址传递
void swapr(int a, int b); // 创建了两个新变量，
```

函数重载虽方便，但是不要滥用，只有执行相同任务但是使用不同形式的数据时，才采用函数重载。

泛型使用举例：注意 template 和 typename 是固定的，而 T 可以随意定义。

```cpp
template <typename T>
void Swap(T &a, T &b) {
    T t;
    t = a;
    a = b;
    b = t;
}
int main() {
    int a = 1 , b = 2 ;
    Swap(a, b);
    cout << a << " " << b << endl;
    return 0;
}
```

编写模板的时候，往往先按特定的数据类型编写，编写完成通过测试数据后再修改成模板。

模板的局限性在于，如果针对数组或结构模板化可能会导致某些常规的运算符无法使用。

> 例如 a > b 如果 a 和 b 都是数组，那么 > 就无法比较了。同样，如果 T 是数组，指针或结构，那么  `T c = a*b;` 中的 * 也就不成立了。需要**重载运算符**。

