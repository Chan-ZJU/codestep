# 第九章：内存模型和名称空间

- 单独编译
- 存储持续性，作用域和链接性。
- 定位 new 运算符。
- 名称空间。

## 单独编译

所有的函数不一定都位于同一个文件中，往往会分散在不同的文件中。但如果位于两个不同文件中的函数使用了同一个结构体，如果每个文件都写一遍结构声明的话势必会造成冗余，而且修改时要修改两遍。

可以创建一个单位的文件将结构体写入其中，该文件称为**头文件**。另外两个函数所在的文件引用该文件即可，该文件称为**源代码文件**。改动之时只需要改动**头文件**即可。

头文件中不允许写**函数定义**和**变量声明**，如果写的话，而源代码文件也写函数声明则会造成**二义性**从而导致出错，内联函数除外。

头文件包含内容：
* 使用 #define 或 const 定义的符号常量。
* 结构声明。（不声明结构变量，而是告诉编译器如何生成结构变量）
* 类声明。
* 模板声明。（此代码不是被编译的，而是告诉编译器如果生成与源代码相匹配的代表如何编译）
* 内联函数。

`<coodin.h>` 和 `"coodin.h"` 的区别，前者会直接去**库**中查找，后者则是在先去**当前工作目录**下查找，当找不到时再去**库**中查找。

**头文件**一般写在当前的工作目录下，所以一般写成双引号的形式而非尖括号，即：`"coodin.h"`。

编译程序时会先将头文件涉及的代码合并起来，生成一个 `.cpp` 源代码文件。

同一个文件中只能包含一次头文件。但是现实往往难以避免这种情况。

为了避免这种情况采用如下的方式来避免：

```cpp
#ifndef a
#define a
// ...
#endif
```

关键字 ifndef 表示 if not define ，也就是先判断 a 是否已经被定义了，如果被定义就直接执行 #endif 后面的语句，反之顺序执行。

这种方法虽然不能防止某个文件被包含两次，但是可以使其忽略除第一包含之外的所有内容。

## 存储持续性，作用域和链接性

C++ 有三种存储数据的方式（C++11 中已是四种）。

* 自动存储持续性：函数或代码块从创建到执行完毕。
* 静态存储持续性：函数外定义的变量和使用关键字 static 定义的变量在整个程序运行过程中都存在。
* 线程存储持续性：（C++11）如果变量是使用关键字 thread_local 声明的，其声明周期和所属线程一样长。
* 动态存储持续性：用 new 运算符分配的内存直到遇到 delete 运算符才将其释放或程序结束。或者称为**自由存储**或**堆**。

函数的**作用域**可以是整个类或整个名称空间甚至全局，但不能是局部的，因为代码块中无法定义函数。

如果变量 a 内部的一个代码块中也定义了一个同名的变量 a ，那么在该代码块中生效的将是新定义的变量 a 。

C++11 之前 auto 是显示的声明一个变量采用自动存储方式，但是没人用。于是在设计 C++11 时又增加了一个自动推导数据类型功能。

变量保存在**栈**中，采用**两个指针**来跟踪栈，一个指针指向栈顶，另一个则指向栈底。栈空间大小可以通过编译器来设置。

关键字 register 用来声明使用 CPU 寄存器来存储变量，为了提高速度。

C++ 有单定义规则，即变量只能定义一次。为了满足这条规则 C++ 存在两种声明变量的方式，一种是定义声明，另外一种是引用声明。二者的区别是前者分配变量而后者不分配。

引用声明采用关键字 extern 且不进行初始化，否则即为定义导致分配空间。

> 例如： `extern int a;` 

作用域解析运算符（::）可以用来访问全局变量。

> 例如：在当前函数中 a = 0.4 ，但是 a 也是全局变量 a = 0.8 ，所以在当前函数中 ::a = 0.8 

被 const 声明的变量内存初始化后就不能再修改。

new 是在堆中找到一个能够满足要求的内存块。

using 编译指令使得所有的名称都能使用。

> 例如：`using namespace std;`  使得 std 中的所有名称都能使用。

而 using 声明只能使特定的名称使用。

> 例如：`using std::cin;` 只能使得 std 名称空间中的 cin 有效。

为了避免名称冲突，尽量不要在头文件中使用using编译命令和using声明。

因为一旦使用后就表明该名称空间中的命名在所有使用该头文件的源代码文件中都有效，项目一大，文件一多容易导致冲突。